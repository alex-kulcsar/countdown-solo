{
  "README.md": " ",
  "assets.json": "",
  "custom.ts": "/**\n * MIT License\n *\n * Copyright (c) 2020 Kasper Unn Weihe\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the Software\n * is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE\n * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\nnamespace String {\n    //% block hidden\n    export function makeUppercase(s: string): string {\n        return s.toUpperCase()\n    }\n\n    //% block hidden\n    export function makeLowercase(s: string): string {\n        return s.toLowerCase()\n    }\n\n    // https://github.com/ka-weihe/fastest-levenshtein\n    const peq: Uint32Array = new Uint32Array(0x10000)\n    function myers_32(a: string, b: string): number {\n        const n = a.length;\n        const m = b.length;\n        const lst = 1 << (n - 1);\n        let pv = -1;\n        let mv = 0;\n        let sc = n;\n        let i = n;\n        while (i--) {\n            // peq[a.charCodeAt(i)] |= 1 << i;\n            peq.set(a.charCodeAt(i),\n                peq.get(a.charCodeAt(i)) | (1 << i))\n        }\n        for (i = 0; i < m; i++) {\n            // let eq = peq[b.charCodeAt(i)];\n            let eq = peq.get(b.charCodeAt(i))\n            const xv = eq | mv;\n            eq |= ((eq & pv) + pv) ^ pv;\n            mv |= ~(eq | pv);\n            pv &= eq;\n            if (mv & lst) {\n                sc++;\n            }\n            if (pv & lst) {\n                sc--;\n            }\n            mv = (mv << 1) | 1;\n            pv = (pv << 1) | ~(xv | mv);\n            mv &= xv;\n        }\n        i = n;\n        while (i--) {\n            // peq[a.charCodeAt(i)] = 0;\n            peq.set(a.charCodeAt(i), 0)\n        }\n        return sc;\n    }\n\n    function myers_x(b: string, a: string): number {\n        const n = a.length;\n        const m = b.length;\n        const mhc = [];\n        const phc = [];\n        const hsize = Math.ceil(n / 32);\n        const vsize = Math.ceil(m / 32);\n        for (let i = 0; i < hsize; i++) {\n            phc[i] = -1;\n            mhc[i] = 0;\n        }\n        let j = 0;\n        for (; j < vsize - 1; j++) {\n            let mv = 0;\n            let pv = -1;\n            const start = j * 32;\n            const vlen = Math.min(32, m) + start;\n            for (let k = start; k < vlen; k++) {\n                // peq[b.charCodeAt(k)] |= 1 << k;\n                peq.set(b.charCodeAt(k),\n                    peq.get(b.charCodeAt(k) | (1 << k)))\n            }\n            for (let i = 0; i < n; i++) {\n                // const eq = peq[a.charCodeAt(i)];\n                const eq = peq.get(a.charCodeAt(i))\n                const pb = (phc[(i / 32) | 0] >>> i) & 1;\n                const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n                const xv = eq | mv;\n                const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n                let ph = mv | ~(xh | pv);\n                let mh = pv & xh;\n                if ((ph >>> 31) ^ pb) {\n                    phc[(i / 32) | 0] ^= 1 << i;\n                }\n                if ((mh >>> 31) ^ mb) {\n                    mhc[(i / 32) | 0] ^= 1 << i;\n                }\n                ph = (ph << 1) | pb;\n                mh = (mh << 1) | mb;\n                pv = mh | ~(xv | ph);\n                mv = ph & xv;\n            }\n            for (let k = start; k < vlen; k++) {\n                // peq[b.charCodeAt(k)] = 0;\n                peq.set(b.charCodeAt(k), 0)\n            }\n        }\n        let mv = 0;\n        let pv = -1;\n        const start = j * 32;\n        const vlen = Math.min(32, m - start) + start;\n        for (let k = start; k < vlen; k++) {\n            // peq[b.charCodeAt(k)] |= 1 << k;\n            peq.set(b.charCodeAt(k),\n                peq.get(b.charCodeAt(k)) | (1 << k))\n        }\n        let score = m;\n        for (let i = 0; i < n; i++) {\n            // const eq = peq[a.charCodeAt(i)];\n            const eq = peq.get(a.charCodeAt(i))\n            const pb = (phc[(i / 32) | 0] >>> i) & 1;\n            const mb = (mhc[(i / 32) | 0] >>> i) & 1;\n            const xv = eq | mv;\n            const xh = ((((eq | mb) & pv) + pv) ^ pv) | eq | mb;\n            let ph = mv | ~(xh | pv);\n            let mh = pv & xh;\n            score += (ph >>> (m - 1)) & 1;\n            score -= (mh >>> (m - 1)) & 1;\n            if ((ph >>> 31) ^ pb) {\n                phc[(i / 32) | 0] ^= 1 << i;\n            }\n            if ((mh >>> 31) ^ mb) {\n                mhc[(i / 32) | 0] ^= 1 << i;\n            }\n            ph = (ph << 1) | pb;\n            mh = (mh << 1) | mb;\n            pv = mh | ~(xv | ph);\n            mv = ph & xv;\n        }\n        for (let k = start; k < vlen; k++) {\n            // peq[b.charCodeAt(k)] = 0;\n            peq.set(b.charCodeAt(k), 0)\n        }\n        return score;\n    }\n\n    //% block=\"levenshtein distance between strings $a and $b\"\n    export function distance(a: string, b: string): number {\n        if (a.length < b.length) {\n            const tmp = b;\n            b = a;\n            a = tmp;\n        }\n        if (b.length === 0) {\n            return a.length;\n        }\n        if (a.length <= 32) {\n            return myers_32(a, b);\n        }\n        return myers_x(a, b);\n    }\n\n    //% block=\"string in array $arr with closest levenshtein distance to string $str\"\n    export function closest(str: string, arr: string[]): string {\n        let min_distance = Infinity;\n        let min_index = 0;\n        for (let i = 0; i < arr.length; i++) {\n            const dist = distance(str, arr[i]);\n            if (dist < min_distance) {\n                min_distance = dist;\n                min_index = i;\n            }\n        }\n        return arr[min_index];\n    }\n}",
  "main.blocks": "<xml xmlns=\"https://developers.google.com/blockly/xml\"><block type=\"pxt-on-start\" x=\"0\" y=\"0\"></block></xml>",
  "main.ts": "\n",
  "pxt.json": "{\n    \"name\": \"String Extensions\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"device\": \"*\",\n        \"pxt-typed-arrays\": \"github:robo-technical-group/pxt-typed-arrays#v1.3.3\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"assets.json\",\n        \"custom.ts\"\n    ],\n    \"targetVersions\": {\n        \"branch\": \"v1.12.57\",\n        \"tag\": \"v1.12.57\",\n        \"commits\": \"https://github.com/microsoft/pxt-arcade/commits/50c17cec0d73d32911acd1633e6ce81b85ed2c3a\",\n        \"target\": \"1.12.57\",\n        \"pxt\": \"8.5.68\"\n    },\n    \"preferredEditor\": \"blocksprj\"\n}\n"
}